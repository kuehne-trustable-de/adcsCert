/*
 * ADCSConnector
 * baseline API to request and revoke certificates from an ADCS instance
 *
 * OpenAPI spec version: 1.0.0-oas3
 * Contact: kuehne@trustable.de
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package de.trustable.ca3s.client.api;

import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.Collection;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

public class ADCSApiClient extends io.swagger.client.ApiClient {


    private TrustManager[] trustManagers;

    /*
     * Constructor for ApiClient
     */
    public ADCSApiClient() {
    	super();

        // Set default User-Agent.
        setUserAgent("ADCSProxyClient/1.0.0/java");

    }

    public TrustManager[] getTrustManagers() {
        return trustManagers;
    }

    /**
     * Configure trust manager to validate authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The TrustManagers to use
     * @return ApiClient
     */
    public ADCSApiClient setTrustManagers(TrustManager[] managers) {
        this.trustManagers = managers;
        applySslSettings();
        return this;
    }

    
    
    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {

            HostnameVerifier hostnameVerifier = null;
            
            if( trustManagers != null ) {
            	// do nothing for trust, enjoy that the trust manager was provided

//            	System.out.println("********************* ApiClient using provided trustManagers '" + trustManagers[0] + "'");

//            	hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
//            	System.out.println("********************* ApiClient using hostnameVerifier '" + hostnameVerifier + "'");
            	
//            	hostnameVerifier = OkHostnameVerifier.INSTANCE;
//            	System.out.println("********************* ApiClient using local hostnameVerifier '" + hostnameVerifier + "'");
/*            	
            	// @Todo : find better way, e.b. by using default HNV
            	// build an accept-all
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                    	System.out.println("********************* ApiClient fake-HNV called for '" + hostname + "'");
                    	return true; 
                    }
                };
*/                
            } else if (!verifyingSsl) {
                TrustManager trustAll = new X509TrustManager() {
                    @Override
                    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
                    @Override
                    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {}
                    @Override
                    public X509Certificate[] getAcceptedIssuers() { return null; }
                };
                SSLContext.getInstance("TLS");
                trustManagers = new TrustManager[]{ trustAll };
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) { return true; }
                };
            } else if (sslCaCert != null) {
                char[] password = null; // Any password will work.
                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                if (certificates.isEmpty()) {
                    throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                }
                KeyStore caKeyStore = newEmptyKeyStore(password);
                int index = 0;
                for (Certificate certificate : certificates) {
                    String certificateAlias = "ca" + Integer.toString(index++);
                    caKeyStore.setCertificateEntry(certificateAlias, certificate);
                }
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                trustManagerFactory.init(caKeyStore);
                trustManagers = trustManagerFactory.getTrustManagers();
            }

            if (keyManagers != null || trustManagers != null) {
                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(keyManagers, trustManagers, new SecureRandom());
                httpClient.setSslSocketFactory(sslContext.getSocketFactory());
            } else {
                httpClient.setSslSocketFactory(null);
            }
            httpClient.setHostnameVerifier(hostnameVerifier);
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

}
